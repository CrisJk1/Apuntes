\section{Algoritmos Greedy}

\subsection{Introduccion}

Un algoritmo voraz es un algoritmo que construye un objeto paso a paso, eligiendo en cada paso la mejor opcion local. En algunos casos, los algoritmos voraces construyen el mejor objeto globalmente al elegir repetidamente la mejor opcion local.

\textbf{No aseguran una solucion optima en todos los casos}.

\newpage
\subsection{Kruskal con Union-Find}
Dado un grafo, ¿cual es la cantidad minima de aristas (y las mas baratas), que me permitan conectar todo el grafo, de forma que exista un camino de un nodo a cualquier otro nodo? Este algoritmo es mejor para grafos dispersos.

\begin{lstlisting}
struct union_find{
    vector<int> e;
    union_find(int n) {e.assign(n, -1);}

    int findSet(int x) {return (e[x] < 0 ? x : e[x] = findSet(e[x]));}
    bool sameSet(int a, int b) {return findSet(a) == findSet(b);}
    bool size(int x) {return -e[findSet(x)];}

    bool unionSet(int x, int y){
        x = findSet(x), y = findSet(y);
        if(x == y) return 0;
        if(e[x] > e[y]) swap(x,y);
        e[x] += e[y], e[y] = x;
        return 1;
    }
};

struct Edge {
    int u, v, w; // origen, destino, peso
};

vector<Edge> kruskal(int n, vector<Edge> &edges){
    // 1. Ordenar aristas por peso
    sort(edges.begin(), edges.end(), [](const Edge &a, const Edge &b){return a.w < b.w;});

    // 2. Inicializar DSU
    union_find uf(n);
    vector<Edge> T;  // MST

    // 3. Recorrer aristas en orden creciente
    for(const Edge &e : edges){
        if(uf.findSet(e.u) != uf.findSet(e.v)){
            // Conecta dos componentes distintas
            T.push_back(e);
            uf.unionSet(e.u, e.v);
        }
    }

    // 4. Retornar el arbol generador minimo
    return T;
\end{lstlisting}
\begin{lstlisting}
int main(){
    int n = 13;  // cantidad de vertices
    vector<Edge> edges = {
        {1,2,1}, {1,3,3}, {2,3,6}, {2,5,7},
        {2,6,5}, {3,4,1}, {3,5,4}, {4,5,9},
        {5,6,8}, {5,7,6}, {5,8,12}, {6,7,7},
        {7,8,2}
    };

    vector<Edge> mst = kruskal(n, edges);

    cout << "Aristas del MST:\n";
    for(auto &e : mst)
        cout << e.u << " - " << e.v << "  peso = " << e.w << "\n";
}
}
\end{lstlisting}

Complejidad Temporal: La fase dominante del algoritmo es la ordenación de las aristas por peso, lo que requiere $O(E \log E)$. Las operaciones posteriores de \texttt{find} y \texttt{union} en la estructura Union-Find tienen costo amortizado $O(1)$, por lo que procesar las $E$ aristas añade sólo $O(E)$. En consecuencia, la complejidad temporal total es $O(E \log E)$. \\

Complejidad Espacial: El algoritmo almacena todas las aristas del grafo, lo que requiere $O(E)$, y utiliza una estructura Union-Find con un vector de tamaño $V$, lo que aporta $O(V)$. Por lo tanto, el uso total de memoria es $O(V + E)$.

\subsection{Prim}
Mismo contexto que Kruskal, pero este algoritmo es mejor para grafos densos y soporta inicio aleatorio.

\begin{lstlisting}
struct Arista {
    int destino;
    long long peso;
};

// Par: {peso, vertice}
struct Nodo {
    long long peso;
    int vertice;
    bool operator>(const Nodo& otro) const {
        return peso > otro.peso; // Min-heap
    }
};

// Funcion mejorada de Prim con inicio aleatorio
pair<long long, vector<pair<int, int>>> prim(int n, vector<vector<Arista>>& grafo, int inicio = -1) {
    // Si no se especifica inicio, elegir uno aleatorio
    if (inicio == -1) {
        srand(time(nullptr));
        inicio = rand() % n;
    }
    
    vector<bool> enMST(n, false);
    priority_queue<Nodo, vector<Nodo>, greater<Nodo>> pq;
    
    vector<pair<int, int>> aristasMST;
    vector<int> padre(n, -1);
    long long pesoTotal = 0;
    
    // Iniciar desde el vertice elegido
    pq.push({0, inicio});
    padre[inicio] = inicio;
    
    int aristas_procesadas = 0;
    
    while (!pq.empty() && aristas_procesadas < n - 1) {
        Nodo actual = pq.top();
        pq.pop();
        
        int v = actual.vertice;
        long long peso = actual.peso;
        
        if (enMST[v]) continue;
        
        // Agregar vertice al MST
        enMST[v] = true;
        pesoTotal += peso;
        
        // Guardar la arista (excepto el nodo inicial)
        if (v != inicio) {
            aristasMST.push_back({padre[v], v});
            aristas_procesadas++;
        }
        
        // Buscar vecino de menor costo no visitado
        for (const Arista& e : grafo[v]) {
            if (!enMST[e.destino]) {
                pq.push({e.peso, e.destino});
                padre[e.destino] = v;
            }
        }
    }
    
    return {pesoTotal, aristasMST};
}
\end{lstlisting}
\newpage
\begin{lstlisting}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int n, m;
    cin >> n >> m;
    
    vector<vector<Arista>> grafo(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        long long w;
        cin >> u >> v >> w;
        grafo[u].push_back({v, w});
        grafo[v].push_back({u, w});
    }
    
    auto [peso, aristas] = prim(n, grafo);
    cout << "Peso MST: " << peso << endl;
    cout << "Aristas:" << endl;
    for (auto [u, v] : aristas) {
        cout << u << " - " << v << endl;
    }
    
    return 0;
}
\end{lstlisting}

Complejidad Temporal: El algoritmo realiza $O(E)$ inserciones en la cola de prioridad, y cada operación cuesta $O(\log V)$ porque la estructura mantiene a lo más $V$ vértices. Por tanto, la complejidad total es $O(E \log V)$.\\

Complejidad Espacial: La lista de adyacencia requiere $O(V + E)$ espacio, y las estructuras auxiliares del algoritmo (visitados, padres y cola de prioridad) usan $O(V)$ adicional. En total, el uso de memoria es $O(V + E)$.

\newpage
\subsection{Dijkstra}
Dado un grafo con pesos no negativos, encuentra el camino mas corto desde un nodo origen a todos los demas nodos.

\begin{lstlisting}
struct Arista {
    int destino;
    long long peso;
};

struct Nodo {
    int vertice;
    long long distancia;
    bool operator>(const Nodo& otro) const {
        return distancia > otro.distancia;
    }
};

pair<vector<long long>, vector<int>> dijkstra(int n, vector<vector<Arista>>& grafo, int inicio) {
    vector<long long> dist(n, LLONG_MAX);
    vector<int> padre(n, -1);
    vector<bool> visitado(n, false);
    priority_queue<Nodo, vector<Nodo>, greater<Nodo>> pq;
    
    dist[inicio] = 0;
    pq.push({inicio, 0});
    
    while (!pq.empty()) {
        Nodo actual = pq.top();
        pq.pop();
        
        int u = actual.vertice;
        if (visitado[u]) continue;
        visitado[u] = true;
        
        for (const Arista& e : grafo[u]) {
            int v = e.destino;
            long long peso = e.peso;
            
            if (dist[u] + peso < dist[v]) {
                dist[v] = dist[u] + peso;
                padre[v] = u;
                pq.push({v, dist[v]});
            }
        }
    }
    return {dist, padre};
}
\end{lstlisting}
\newpage
\begin{lstlisting}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int n, m, inicio;
    cin >> n >> m >> inicio;
    
    vector<vector<Arista>> grafo(n);
    
    for (int i = 0; i < m; i++) {
        int u, v;
        long long w;
        cin >> u >> v >> w;
        grafo[u].push_back({v, w});
    }
    
    auto [dist, padre] = dijkstra(n, grafo, inicio);
    
    for (int i = 0; i < n; i++) {
        if (dist[i] == LLONG_MAX) {
            cout << inicio << " -> " << i << ": INF" << endl;
        } else {
            cout << inicio << " -> " << i << ": " << dist[i] << " [";
            vector<int> camino;
            for (int v = i; v != -1; v = padre[v]) camino.push_back(v);
            reverse(camino.begin(), camino.end());
            for (int j = 0; j < camino.size(); j++) {
                cout << camino[j];
                if (j < camino.size() - 1) cout << " -> ";
            }
            cout << "]" << endl;
        }
    }
    return 0;
}
\end{lstlisting}

Complejidad temporal: $O((V + E)\log V)$, debido a que cada vértice se extrae a lo más una vez desde la cola de prioridad, y cada extracción cuesta $O(\log V)$. Ademas cada arista puede relajar una vez, produciendo una inserción en la cola de prioridad, también de costo $O(\log V)$. \\

Complejidad espacial: $O(V + E)$, ya que se almacenan las listas de adyacencia del grafo ($E$) y las estructuras auxiliares como distancias, visitados y padres ($V$).

\newpage

\subsection{Bellman Ford}
Encuentra el camino mas corto desde un nodo origen a un nodo destino, incluso si el grafo tiene aristas con pesos negativos. Detecta ciclos negativos.

\begin{lstlisting}
void bellmanFord(const vector<vector<int>>& aristas, int n, int inicio, int fin) {
    vector<int> dist(n, INT_MAX);
    vector<int> pred(n, -1);
    dist[inicio] = 0;
    
    // Optimizacion: detener si no hay cambios
    bool cambio = true;
    for (int i = 0; i < n - 1 && cambio; i++) {
        cambio = false;
        for (const auto& e : aristas) {
            if (dist[e[0]] != INT_MAX && dist[e[0]] + e[2] < dist[e[1]]) {
                dist[e[1]] = dist[e[0]] + e[2];
                pred[e[1]] = e[0];
                cambio = true;
            }
        }
    }
    
    // Verificar ciclo negativo
    for (const auto& e : aristas) {
        if (dist[e[0]] != INT_MAX && dist[e[0]] + e[2] < dist[e[1]]) {
            cout << "\nERROR: Ciclo negativo detectado\n";
            return;
        }
    }
    
    if (dist[fin] == INT_MAX) {
        cout << "\nNo existe camino de " << inicio << " a " << fin << "\n";
        return;
    }
    
    // Reconstruir camino
    vector<int> camino;
    for (int v = fin; v != -1; v = pred[v])
        camino.push_back(v);
    
    cout << "\n==============================================\n";
    cout << "Nodo " << inicio << " -> Nodo " << fin << "\n";
    cout << "==============================================\n";
    cout << "Costo: " << dist[fin] << "\n";
    cout << "Camino: ";
    for (int i = camino.size() - 1; i >= 0; i--) {
        cout << camino[i];
        if (i > 0) cout << " -> ";
    }
    cout << "\n==============================================\n\n";
}
\end{lstlisting}
\newpage
\begin{lstlisting}
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int n, m, inicio;
    cin >> n >> m >> inicio;
    
    vector<vector<int>> aristas;
    for (int i = 0; i < m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        aristas.push_back({u, v, w});
    }
    
    vector<int> dist(n, INT_MAX);
    vector<int> pred(n, -1);
    dist[inicio] = 0;
    
    // Relajar aristas V-1 veces
    for (int i = 0; i < n - 1; i++) {
        for (const auto& e : aristas) {
            if (dist[e[0]] != INT_MAX && dist[e[0]] + e[2] < dist[e[1]]) {
                dist[e[1]] = dist[e[0]] + e[2];
                pred[e[1]] = e[0];
            }
        }
    }
    
    // Detectar ciclo negativo
    for (const auto& e : aristas) {
        if (dist[e[0]] != INT_MAX && dist[e[0]] + e[2] < dist[e[1]]) {
            cout << "\n CICLO NEGATIVO DETECTADO" << endl;
            cout << "Arista problema: " << e[0] << " -> " << e[1] << " (peso: " << e[2] << ")" << endl;
            return 0;
        }
    }
    
    for (int i = 0; i < n; i++) {
        if (dist[i] == INT_MAX) {
            cout << inicio << " -> " << i << ": INF" << endl;
        } else {
            cout << inicio << " -> " << i << ": " << dist[i] << " [";
            vector<int> camino;
            for (int v = i; v != -1; v = pred[v]) camino.push_back(v);
            reverse(camino.begin(), camino.end());
            for (int j = 0; j < camino.size(); j++) {
                cout << camino[j];
                if (j < camino.size() - 1) cout << " -> ";
            }
            cout << "]" << endl;
        }
    }
    return 0;
}
\end{lstlisting}

\newpage

\subsection{Problema de Scheduling}
Se te da una lista de actividades $(s_1, e_1), \ldots, (s_n, e_n)$ denotadas por sus tiempos de inicio y finalizacion. Todas las actividades son igualmente atractivas para ti, y deseas maximizar el numero de actividades que realizas. \\
Objetivo: Escoger la mayor cantidad de actividades no superpuestas posible.

\begin{lstlisting}
struct Activity {
    int s, e; // start, end
};

vector<Activity> schedule(vector<Activity> &a){
    // 1. Ordenar por tiempo de finalizacion
    sort(a.begin(), a.end(), [](const Activity &x, const Activity &y){return x.e < y.e;});

    vector<Activity> chosen;

    if(a.empty()) return chosen;

    // 2. Seleccionar la primera actividad
    chosen.push_back(a[0]);
    int last_end = a[0].e;

    // 3. Recorrer el resto y tomar las compatibles
    for(int i = 1; i < a.size(); i++){
        if(a[i].s >= last_end){
            chosen.push_back(a[i]);
            last_end = a[i].e;
        }
    }

    return chosen;
}
\end{lstlisting}


Complejidad Temporal: $O(n \log n)$ debido a sort. \\
Complejidad Espacial: $O(n)$ en el peor caso donde todas las actividades son compatibles.

\subsection{Mochila fraccionaria}
Problema de la mochila clasico donde los objetos pueden ser divididos en partes mas pequeñas. \\
Objetivo: Maximizar el valor total en la mochila sin exceder su capacidad.

\begin{lstlisting}
struct Item {
    double value, weight;
};

double fractionalKnapsack(double W, vector<Item> &items){
    // 1. Ordenar por ratio (value/weight)
    sort(items.begin(), items.end(), [](const Item &a, const Item &b){
        return (a.value / a.weight) > (b.value / b.weight);});

    double totalValue = 0.0;

    // 2. Llenar la mochila
    for(const auto &it : items){
        if(W == 0) break;

        // Si cabe entero
        if(it.weight <= W){
            W -= it.weight;
            totalValue += it.value;
        }
        // Tomar fraccion
        else{
            double fraction = W / it.weight;
            totalValue += it.value * fraction;
            W = 0;
        }
    }

    return totalValue;
}
\end{lstlisting}

Complejidad Temporal: $O(n \log n)$ debido a sort. \\
Complejidad Espacial: $O(1)$ si se ordena in-place, $O(\log n)$ en caso contrario.

\subsection{Huffman}

Algoritmo de compresión de datos que asigna códigos binarios de longitud variable a los símbolos, basándose en su frecuencia de aparición.

\subsubsection*{Estructura del Nodo y Comparador}

\begin{lstlisting}
struct Node {
    char c;                // simbolo (solo en hojas)
    int freq;              // frecuencia del subarbol
    Node *left, *right;    // hijos

    Node(char c, int freq) : c(c), freq(freq), left(NULL), right(NULL) {}
    Node(Node* l, Node* r) : c('\0'), freq(l->freq + r->freq), left(l), right(r) {}
};

struct Compare {
    bool operator()(Node* a, Node* b) {
        return a->freq > b->freq; // min-heap
    }
};
\end{lstlisting}

\subsubsection*{Construcción del Árbol}

\begin{lstlisting}
Node* buildHuffmanTree(const unordered_map<char, int> &freq) {
    priority_queue<Node*, vector<Node*>, Compare> F;

    // 1. Crear un arbol para cada simbolo
    for (auto &p : freq) {
        F.push(new Node(p.first, p.second));
    }

    // 2. Fusionar arboles hasta tener uno solo
    while (F.size() > 1) {
        Node* T1 = F.top(); F.pop();
        Node* T2 = F.top(); F.pop();
        F.push(new Node(T1, T2));
    }

    return F.top();
}
\end{lstlisting}

\begin{multicols}{2}
\subsubsection*{Generación de Códigos}

\begin{lstlisting}
void generateCodes(Node* root, 
                   string code, 
                   unordered_map<char, string> &mp) {
    if (!root) return;

    // Hoja: asignar codigo
    if (!root->left && !root->right) {
        mp[root->c] = code;
    }

    generateCodes(root->left,  code + "0", mp);
    generateCodes(root->right, code + "1", mp);
}
\end{lstlisting}

\columnbreak

\subsubsection*{Codificación}

\begin{lstlisting}
string encode(const string &text, 
              unordered_map<char,string> &codeMap) {
    string encoded;
    for (char c : text) 
        encoded += codeMap[c];
    return encoded;
}
\end{lstlisting}
\end{multicols}

\newpage
\subsubsection*{Decodificación}

\begin{lstlisting}
string decode(Node* root, const string &encoded) { // T:O(n) S:O(1)
    string result;
    Node* curr = root;

    for (char bit : encoded) {
        curr = (bit == '0') ? curr->left : curr->right;

        // Llegamos a una hoja
        if (!curr->left && !curr->right) {
            result += curr->c;
            curr = root; // volver a la raiz
        }
    }
    return result;
}
\end{lstlisting}

\subsubsection*{Ejemplo de Uso}

\begin{lstlisting}
int main() {
    string text = "huffman example";

    // Contar frecuencias
    unordered_map<char,int> freq;
    for (char c : text) freq[c]++;

    // Construir arbol y generar codigos
    Node* root = buildHuffmanTree(freq);
    unordered_map<char,string> codeMap;
    generateCodes(root, "", codeMap);

    // Codificar y decodificar
    string encoded = encode(text, codeMap);
    string decoded = decode(root, encoded);

    return 0;
}
\end{lstlisting}

\textbf{Complejidad Temporal:} $O(n \log n)$. Se inserta n nodos en la priority\_queue $O(n \log n)$ en total. Cada iteracion extraen dos nodos minimos con pop() $O(2(n-1) \cdot \log n) = O(n \log n)$. Cada fusion inserta un nuevo nodo $O((n-1) \log n) = O(n \log n)$. Todo lo demas es $O(1)$\\
\textbf{Complejidad Espacial:} $O(n)$. El arbol final tiene $2n-1$ nodos, priority\_queue tiene a lo mas $n$ nodos.
