\section{Contenedor \texttt{deque}}

\subsection{Introducción}
\texttt{deque} (double-ended queue) es un contenedor secuencial que permite inserción y eliminación eficiente en \textbf{ambos extremos}.
A diferencia de \texttt{vector}, no garantiza almacenamiento contiguo, sino que usa múltiples bloques de memoria.
Ofrece acceso aleatorio por índice similar a \texttt{vector}, pero con mejor rendimiento en inserciones/eliminaciones al inicio.
Es el contenedor por defecto usado por \texttt{stack} y \texttt{queue}.

\subsection{Operaciones importantes}

\subsubsection{Declaración e inicialización}
\begin{lstlisting}
#include <deque>
#include <string>

deque<int> d1;                  // vacio
deque<int> d2(5);               // 5 elementos inicializados a 0
deque<int> d3(5, 42);           // 5 elementos con valor 42
deque<int> d4 = {1, 2, 3, 4};   // inicializacion con lista
deque<string> names = {"Ana", "Luis"};
\end{lstlisting}

\subsubsection{Agregar elementos al final: \texttt{push\_back()}}
Añade un elemento al final. Complejidad O(1).
\begin{lstlisting}
deque<int> d;
d.push_back(10);
d.push_back(20); // d = {10, 20}
\end{lstlisting}

\subsubsection{Agregar elementos al inicio: \texttt{push\_front()}}
Añade un elemento al inicio. Complejidad O(1).
\begin{lstlisting}
d.push_front(5); // d = {5, 10, 20}
d.push_front(1); // d = {1, 5, 10, 20}
\end{lstlisting}

\subsubsection{Eliminar último elemento: \texttt{pop\_back()}}
Elimina el último elemento (no devuelve su valor).
\begin{lstlisting}
if (!d.empty()) {
    d.pop_back(); // elimina 20
}
\end{lstlisting}

\subsubsection{Eliminar primer elemento: \texttt{pop\_front()}}
Elimina el primer elemento (no devuelve su valor).
\begin{lstlisting}
if (!d.empty()) {
    d.pop_front(); // elimina 1
}
\end{lstlisting}

\subsubsection{Acceso a elementos: \texttt{operator[]} y \texttt{at()}}
\texttt{operator[]} no comprueba límites; \texttt{at()} lanza \texttt{out\_of\_range} si el índice no es válido.
\begin{lstlisting}
d[0] = 99;          // rapido, sin comprobacion
try {
    d.at(1) = 77;   // seguro
} catch (const out_of_range& e) {
    // manejo de error
}
int x = d[0];       // lectura
\end{lstlisting}

\subsubsection{Primer y último elemento}
\begin{lstlisting}
if (!d.empty()) {
    cout << "first: " << d.front() 
         << ", last: " << d.back();
    d.front() = 100; // modificar
    d.back() = 200;
}
\end{lstlisting}

\subsubsection{Tamaño y estado}
\begin{lstlisting}
cout << "size: " << d.size() << "\n";
if (d.empty()) cout << "vacio\n";
\end{lstlisting}

\subsubsection{Cambiar tamaño}
\texttt{resize(n)} cambia el tamaño lógico del deque.
\begin{lstlisting}
d.resize(8);      // cambia tamano a 8 (anade ceros)
d.resize(3);      // reduce tamano a 3
\end{lstlisting}

\subsubsection{Insertar y borrar en posiciones arbitrarias}
Inserta o elimina en el medio (coste O(n), pero más eficiente que vector cerca de los extremos).
\begin{lstlisting}
deque<int> a = {1, 2, 4, 5};
auto it = a.begin() + 2;   // apunta al 4
a.insert(it, 3);           // a = {1, 2, 3, 4, 5}
a.erase(a.begin() + 1);    // a = {1, 3, 4, 5}
\end{lstlisting}

\subsubsection{Recorrer el deque}
\begin{lstlisting}
// range-based for
for (int x : a) cout << x << ' ';

// iteradores
for (auto it = a.begin(); it != a.end(); ++it)
    *it += 1;

// por indice
for (size_t i = 0; i < a.size(); ++i)
    cout << a[i] << ' ';
\end{lstlisting}

\subsubsection{Eliminar todos los elementos}
\begin{lstlisting}
a.clear(); // tamano 0
\end{lstlisting}

\subsubsection{Intercambiar contenidos}
\begin{lstlisting}
deque<int> x = {1, 2, 3}, y = {9, 8};
x.swap(y); // x = {9, 8}, y = {1, 2, 3}
\end{lstlisting}

\subsection{Complejidad típica}
\begin{itemize}
  \item Acceso por índice: O(1)
  \item \texttt{push\_front}, \texttt{push\_back}: O(1)
  \item \texttt{pop\_front}, \texttt{pop\_back}: O(1)
  \item \texttt{insert}/\texttt{erase} en medio: O(n)
  \item \texttt{clear}: O(n)
\end{itemize}

\subsection{Diferencias con \texttt{vector}}
\begin{itemize}
  \item Inserción/eliminación O(1) al inicio (vs O(n) en vector)
  \item No garantiza memoria contigua
  \item Ligeramente más lento en acceso aleatorio
  \item No tiene \texttt{capacity()} ni \texttt{reserve()}
\end{itemize}
