\section{Contenedor \texttt{vector}}

\subsection{Introducción}
\texttt{vector} es un contenedor secuencial de la STL que ofrece un \textbf{arreglo dinamico}: los elementos se almacenan en memoria contigua y el vector puede crecer o reducir su tamano automaticamente. 
Es ideal cuando se necesita \textbf{acceso aleatorio por indice} y crecimiento dinamico. 
Las operaciones de insercion o eliminacion al final son rapidas (amortizadas O(1)), pero insertar o borrar en el medio o al inicio puede ser costoso (O(n)).

\subsection{Operaciones importantes}

\subsubsection{Declaracion e inicializacion}
\begin{lstlisting}
#include <vector>
#include <string>

// Declaraciones
vector<int> v1;                 // vacio
vector<int> v2(5);              // 5 elementos inicializados a 0
vector<int> v3(5, 42);          // 5 elementos con valor 42
vector<int> v4 = {1, 2, 3, 4};  // inicializacion con lista
vector<string> names = {"Ana","Luis"};
\end{lstlisting}

\subsubsection{Agregar elementos: \texttt{push\_back()}}
Anade un elemento al final del vector. Complejidad amortizada O(1).
\begin{lstlisting}
vector<int> v;
v.push_back(10);
v.push_back(20); // v = {10, 20}
\end{lstlisting}

\subsubsection{Eliminar último elemento: \texttt{pop\_back()}}
Elimina el último elemento (no devuelve su valor).
\begin{lstlisting}
if (!v.empty()) {
    v.pop_back(); // elimina 20
}
\end{lstlisting}

\subsubsection{Acceso a elementos: \texttt{operator[]} y \texttt{at()}}
\texttt{operator[]} no comprueba limites; \texttt{at()} lanza \texttt{out\_of\_range} si el indice no es valido.
\begin{lstlisting}
v[0] = 5;           // rapido, sin comprobacion
try {
    v.at(2) = 7;    // seguro
} catch (const out_of_range& e) {
    // manejo de error
}
int x = v[0];       // lectura
\end{lstlisting}

\subsubsection{Tamano y capacidad}
\begin{lstlisting}
cout << "size: " << v.size() << "\n";
cout << "capacity: " << v.capacity() << "\n";
if (v.empty()) cout << "vacio\n";
\end{lstlisting}

\subsubsection{Reservar espacio y cambiar tamano}
\texttt{reserve(n)} reserva capacidad; \texttt{resize(n)} cambia el tamano logico.
\begin{lstlisting}
v.reserve(100);   // reserva espacio para 100 elementos
v.resize(8);      // cambia tamano a 8 (anade ceros)
v.resize(3);      // reduce tamano a 3
\end{lstlisting}

\subsubsection{Insertar y borrar en posiciones arbitrarias}
Inserta o elimina en el medio (coste O(n)).
\begin{lstlisting}
vector<int> a = {1,2,4,5};
auto it = a.begin() + 2;   // apunta al 4
a.insert(it, 3);           // a = {1,2,3,4,5}
a.erase(a.begin() + 1);    // a = {1,3,4,5}
\end{lstlisting}

\subsubsection{Recorrer el vector}
\begin{lstlisting}
// range-based for
for (int x : a) cout << x << ' ';

// iteradores
for (auto it = a.begin(); it != a.end(); ++it)
    *it += 1;

// por indice
for (size_t i = 0; i < a.size(); ++i)
    cout << a[i] << ' ';
\end{lstlisting}

\subsubsection{Primer y último elemento}
\begin{lstlisting}
if (!a.empty()) {
    cout << "first: " << a.front() 
              << ", last: " << a.back();
}
\end{lstlisting}

\subsubsection{Eliminar todos los elementos}
\begin{lstlisting}
a.clear(); // tamano 0, mantiene capacidad
// liberar memoria
a.shrink_to_fit(); 
\end{lstlisting}

\subsubsection{Intercambiar contenidos}
\begin{lstlisting}
vector<int> x = {1,2,3}, y = {9,8};
x.swap(y); // x = {9,8}, y = {1,2,3}
\end{lstlisting}

\subsection{Complejidad tipica}
\begin{itemize}
  \item Acceso por indice: O(1)
  \item \texttt{push\_back}: amortizada O(1)
  \item \texttt{insert}/\texttt{erase} en medio: O(n)
  \item \texttt{clear}: O(n)
\end{itemize}
